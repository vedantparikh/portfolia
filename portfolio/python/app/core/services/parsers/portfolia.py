"""
Portfolia PDF Parser for parsing app-generated transaction PDFs.
"""

import io
import re
from datetime import datetime
from decimal import Decimal
from typing import List, Tuple

import pypdf

from core.database.models.transaction import TransactionType
from core.schemas.account_statements import (
    ParsedData,
    ParsedTransaction,
    ParsingMetadata,
    StatementPeriod,
)
from core.services.parsers.base import PDFParser


class PortfoliaParser(PDFParser):
    """
    Parser for Portfolia app-generated transaction PDFs.
    This parser handles PDFs generated by the Portfolia application's export feature.
    """

    def parse(self, pdf_content: bytes) -> ParsedData:
        """Parse Portfolia-generated PDF statement."""
        try:
            pdf_reader = pypdf.PdfReader(io.BytesIO(pdf_content))
            full_text = ""
            for page in pdf_reader.pages:
                full_text += page.extract_text() + "\n"

            if not self._validate_portfolia_pdf(full_text):
                return ParsedData(
                    provider="portfolia",
                    statement_period=StatementPeriod(start_date="", end_date=""),
                    transactions=[],
                    metadata=ParsingMetadata(
                        total_transactions=0,
                        warnings=["This does not appear to be a Portfolia-generated PDF"],
                    ),
                )

            statement_period = self._extract_statement_period(full_text)
            transactions, warnings = self._extract_transactions(full_text)

            # Add a generic parsed from file warning if it's not already there from other errors
            if not any("Parsed from file:" in w for w in warnings):
                warnings.insert(0, f"Parsed from file: transactions_report.pdf")

            return ParsedData(
                provider="portfolia",
                statement_period=statement_period,
                transactions=transactions,
                metadata=ParsingMetadata(
                    total_transactions=len(transactions), warnings=warnings
                ),
            )

        except Exception as e:
            return ParsedData(
                provider="portfolia",
                statement_period=StatementPeriod(start_date="", end_date=""),
                transactions=[],
                metadata=ParsingMetadata(
                    total_transactions=0, warnings=[f"PDF parsing failed: {str(e)}"]
                ),
            )

    def _validate_portfolia_pdf(self, text: str) -> bool:
        """Check if PDF was generated by Portfolia application."""
        markers = [
            "Transaction Report",
            "Summary Statistics",
            "Transaction Details",
            "This report was generated by Portfolia",
        ]
        return sum(1 for marker in markers if marker in text) >= 3

    def _extract_statement_period(self, text: str) -> StatementPeriod:
        """Extract statement period from PDF text."""
        # Match "Date Range" followed by the date range on the next line.
        match = re.search(r"Date Range\s*\n([^\n]+)", text)
        if match:
            date_range_str = match.group(1).strip()
            if " to " in date_range_str:
                start_date, end_date = date_range_str.split(" to ")
                return StatementPeriod(start_date=start_date.strip(), end_date=end_date.strip())
        return StatementPeriod(start_date="", end_date="")

    def _extract_transactions(self, text: str) -> Tuple[List[ParsedTransaction], List[str]]:
        """Extract transaction data from PDF text."""
        transactions: List[ParsedTransaction] = []
        warnings: List[str] = []

        table_start = text.find("Transaction Details")
        if table_start == -1:
            warnings.append("Could not find 'Transaction Details' section")
            return transactions, warnings

        # Isolate the text from "Transaction Details" onwards
        table_text = text[table_start:]

        # Find where the data starts (after the 'Fees' header)
        header_end = table_text.find("Fees")
        if header_end == -1:
            warnings.append("Could not find transaction table header.")
            return transactions, warnings

        # Get everything after 'Fees' and before the final footer
        data_text = table_text[header_end + len("Fees"):]
        footer_start = data_text.find("This report was generated by Portfolia")
        if footer_start != -1:
            data_text = data_text[:footer_start]

        # Split the entire data block into a flat list of words/tokens
        data_tokens = data_text.strip().split()

        transaction_groups = []
        current_group = []
        date_pattern = re.compile(r"^\d{4}-\d{2}-\d{2}$")

        for token in data_tokens:
            if date_pattern.match(token):
                if current_group:  # If we have a group, add it to the list
                    transaction_groups.append(current_group)
                current_group = [token]  # Start a new group
            else:
                current_group.append(token)

        if current_group:  # Add the last group
            transaction_groups.append(current_group)

        for i, group in enumerate(transaction_groups):
            try:
                transaction = self._parse_transaction_row(group, i, warnings)
                if transaction:
                    transactions.append(transaction)
            except Exception as e:
                warnings.append(f"Failed to process transaction group: {group} - {str(e)}")

        if not transactions and table_start != -1:
            warnings.append("Found transaction table but no valid transactions were parsed")

        return transactions, warnings

    def _parse_transaction_row(self, parts: List[str], transaction_id: int, warnings: List[str]) -> ParsedTransaction:
        """Parse a single transaction from a list of its parts."""
        if len(parts) < 8:
            warnings.append(f"Could not parse row, too few columns: {parts}")
            return None

        try:
            # Asset names can have spaces, so we parse known columns from the ends inwards
            date_str = parts[0]
            type_str = parts[1]
            symbol = parts[2]

            fees_str = parts[-1]
            total_str = parts[-2]
            price_str = parts[-3]
            qty_str = parts[-4]
            asset_name = " ".join(parts[3:-4])

            transaction_type = self._map_transaction_type(type_str)

            quantity = Decimal(qty_str)
            price = Decimal(price_str.replace("$", "").replace(",", ""))
            total_amount = Decimal(total_str.replace("$", "").replace(",", ""))
            fees = Decimal(fees_str.replace("$", "").replace(",", ""))

            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                transaction_date = date_str
            except ValueError:
                warnings.append(f"Invalid date format found: {date_str}")
                transaction_date = date_str

            return ParsedTransaction(
                id=f"portfolia_{transaction_id}",
                transaction_date=transaction_date,
                transaction_type=transaction_type,
                name=asset_name,
                symbol=symbol,
                total_amount=total_amount,
                quantity=quantity,
                price=price,
                fees=fees,
            )
        except (ValueError, IndexError, TypeError) as e:
            # This exception is for developers, so we raise it to be caught by the outer try/except
            raise ValueError(f"Failed parsing row parts '{parts}': {str(e)}")

    def _map_transaction_type(self, type_str: str) -> str:
        """Map parsed transaction type string to TransactionType enum values."""
        type_mapping = {
            "buy": TransactionType.BUY,
            "sell": TransactionType.SELL,
        }
        return type_mapping.get(type_str.lower(), TransactionType.OTHER)

