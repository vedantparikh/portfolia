"""
Portfolia PDF Parser for parsing app-generated transaction PDFs.
"""

import io
import re
from datetime import datetime
from decimal import Decimal
from typing import List, Tuple

import pypdf

from core.database.models.transaction import TransactionType
from core.schemas.account_statements import (
    ParsedData,
    ParsedTransaction,
    ParsingMetadata,
    StatementPeriod,
)
from core.services.parsers.base import PDFParser


class PortfoliaParser(PDFParser):
    """
    Parser for Portfolia app-generated transaction PDFs.
    This parser handles PDFs generated by the Portfolia application's export feature.
    """

    def parse(self, pdf_content: bytes) -> ParsedData:
        """Parse Portfolia-generated PDF statement."""
        try:
            # Read PDF
            pdf_reader = pypdf.PdfReader(io.BytesIO(pdf_content))

            # Extract text from all pages
            full_text = ""
            for page in pdf_reader.pages:
                full_text += page.extract_text() + "\n"

            # Validate if it's a Portfolia PDF
            if not self._validate_portfolia_pdf(full_text):
                return ParsedData(
                    provider="portfolia",
                    statement_period=StatementPeriod(start_date="", end_date=""),
                    transactions=[],
                    metadata=ParsingMetadata(
                        total_transactions=0,
                        warnings=[
                            "This does not appear to be a Portfolia-generated PDF"
                        ],
                    ),
                )

            # Extract statement period
            statement_period = self._extract_statement_period(full_text)

            # Extract transactions
            transactions, warnings = self._extract_transactions(full_text)

            return ParsedData(
                provider="portfolia",
                statement_period=statement_period,
                transactions=transactions,
                metadata=ParsingMetadata(
                    total_transactions=len(transactions),
                    warnings=warnings,
                ),
            )

        except Exception as e:
            return ParsedData(
                provider="portfolia",
                statement_period=StatementPeriod(start_date="", end_date=""),
                transactions=[],
                metadata=ParsingMetadata(
                    total_transactions=0,
                    warnings=[f"PDF parsing failed: {str(e)}"],
                ),
            )

    def _validate_portfolia_pdf(self, text: str) -> bool:
        """Check if PDF was generated by Portfolia application."""
        # The text extraction includes quotes around headers, so we match that.
        markers = [
            "Transaction Report",
            "Summary Statistics",
            "Transaction Details",
            "This report was generated by Portfolia",
        ]

        found_markers = sum(1 for marker in markers if marker in text)
        return found_markers >= 3

    def _extract_statement_period(self, text: str) -> StatementPeriod:
        """Extract statement period from PDF text."""
        # The PDF text extraction formats this line like a CSV row
        date_range_pattern = r"\"Date Range\n?\"\s*,\s*\"([^\"]+)\""
        match = re.search(date_range_pattern, text)

        if match:
            date_range_str = match.group(1).strip()
            if " to " in date_range_str:
                start_date, end_date = date_range_str.split(" to ")
                return StatementPeriod(
                    start_date=start_date.strip(), end_date=end_date.strip()
                )

        return StatementPeriod(start_date="", end_date="")

    def _extract_transactions(
            self, text: str
    ) -> Tuple[List[ParsedTransaction], List[str]]:
        """Extract transaction data from PDF text."""
        transactions: List[ParsedTransaction] = []
        warnings: List[str] = []

        # Look for the transaction table section
        table_start = text.find("Transaction Details")
        if table_start == -1:
            warnings.append("Could not find 'Transaction Details' section")
            return transactions, warnings

        table_text = text[table_start:]
        lines = table_text.splitlines()

        header_found = False
        transaction_count = 0

        # Regex to identify a transaction row (starts with a quoted date)
        transaction_row_pattern = re.compile(r'^"\d{4}-\d{2}-\d{2}')

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # The header line in the extracted text looks like this
            if '"Date\n","Type\n","Symbol\n"' in line:
                header_found = True
                continue

            if not header_found:
                continue

            if "This report was generated by Portfolia" in line:
                break

            # Check if the line matches the expected transaction format
            if transaction_row_pattern.match(line):
                try:
                    transaction = self._parse_transaction_row(line, transaction_count, warnings)
                    if transaction:
                        transactions.append(transaction)
                        transaction_count += 1
                except Exception as e:
                    warnings.append(
                        f"Failed to parse transaction row: {line[:70]}... - {str(e)}"
                    )

        if not transactions and header_found:
            warnings.append(
                "Found transaction table but no valid transactions were parsed"
            )

        return transactions, warnings

    def _parse_transaction_row(
            self, row: str, transaction_id: int, warnings: List[str]
    ) -> ParsedTransaction:
        """Parse a single transaction row from the table."""
        # The row is formatted like a CSV line. We split by '","'
        # and clean up the start/end quotes and internal newlines.
        parts = [p.strip().strip('"').replace('\n', '') for p in row.split('","')]

        if len(parts) < 8:  # Date, Type, Symbol, Name, Qty, Price, Total, Fees
            return None

        try:
            date_str, type_str, symbol, asset_name, qty_str, price_str, total_str, fees_str = parts[:8]

            transaction_type = self._map_transaction_type(type_str.lower())

            # Clean and parse numeric values
            quantity = Decimal(qty_str.replace(",", "."))
            price = Decimal(price_str.replace("$", "").replace(",", ""))
            total_amount = Decimal(total_str.replace("$", "").replace(",", ""))
            fees = Decimal(fees_str.replace("$", "").replace(",", ""))

            # Validate date format
            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                transaction_date = date_str
            except ValueError:
                # Handle potential date parsing errors if format changes
                warnings.append(f"Invalid date format found: {date_str}")
                transaction_date = date_str  # Keep original string as fallback

            return ParsedTransaction(
                id=f"portfolia_{transaction_id}",
                transaction_date=transaction_date,
                transaction_type=transaction_type,
                name=asset_name,
                symbol=symbol if symbol != "-" else None,
                total_amount=total_amount,
                quantity=quantity,
                price=price,
                fees=fees,
            )

        except (ValueError, IndexError, TypeError) as e:
            raise ValueError(f"Failed parsing row parts: {parts} - Error: {str(e)}")

    def _map_transaction_type(self, type_str: str) -> str:
        """Map parsed transaction type string to TransactionType enum values."""
        type_mapping = {
            "buy": TransactionType.BUY,
            "sell": TransactionType.SELL,
            "dividend": TransactionType.DIVIDEND,
            "split": TransactionType.SPLIT,
            "merger": TransactionType.MERGER,
            "spin_off": TransactionType.SPIN_OFF,
            "rights_issue": TransactionType.RIGHTS_ISSUE,
            "stock_option_exercise": TransactionType.STOCK_OPTION_EXERCISE,
            "option_exercise": TransactionType.STOCK_OPTION_EXERCISE,
            "transfer_in": TransactionType.TRANSFER_IN,
            "transfer_out": TransactionType.TRANSFER_OUT,
            "fee": TransactionType.FEE,
            "other": TransactionType.OTHER,
        }
        return type_mapping.get(type_str.lower().replace(" ", "_"), TransactionType.OTHER)


